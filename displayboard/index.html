<html>
<head>

<script src="/static/d3.min.js"></script>
<link href='/static/index.css' rel='stylesheet'>

</head>

<body>
<script>
var proto = (window.location.protocol === "https") ? "wss:" : "ws:";
var webSocket = new WebSocket(proto + "//" + location.host + "/websocket");

var BORDER_WIDTH = 10;
var LEGEND_HEIGHT = 82;

var TEAM_WIDTH = 200;
var TEAM_HEIGHT = 150;

var g_teams = [];
var g_legend = null;

var svg = d3.select("body").append("svg")
                           .attr("width", document.body.clientWidth)
                           .attr("height", document.body.clientHeight)
                           .attr("class", "pcdccontainer");


function lookupTeam(teamname) {
  return d3.selectAll(".team")
    .filter(function(d) {
      return d.name === teamname;
    })
    .data()[0];
}

function calcMidpoint(x1, y1, x2, y2, bend) {
  if (y2 < y1 && x2 < x1) {
    var tmpy = y2;
    var tmpx = x2;
    x2 = x1;
    y2 = y1;
    x1 = tmpx;
    y1 = tmpy;
  }
  else if (y2 < y1) {
    y1 = y2 + (y2=y1, 0);
  }
  else if (x2 < x1) {
    x1 = x2 + (x2=x1, 0);
  }

  var radian = Math.atan(-((y2 - y1) / (x2 - x1)));
  var r = Math.sqrt(x2 - x1) + Math.sqrt(y2 - y1);
  var m1 = (x1 + x2) / 2;
  var m2 = (y1 + y2) / 2;

  var min = 2.5, max = 7.5;
  //var min = 1, max = 7;
  var arcIntensity = parseFloat((Math.random() * (max - min) + min).toFixed(2));

  if (bend === true) {
    var a = Math.floor(m1 - r * arcIntensity * Math.sin(radian));
    var b = Math.floor(m2 - r * arcIntensity * Math.cos(radian));
  }
  else {
    var a = Math.floor(m1 + r * arcIntensity * Math.sin(radian));
    var b = Math.floor(m2 + r * arcIntensity * Math.cos(radian));
  }

  return {"x": a, "y": b};
}

function translateAlong(path) {
  var l = path.getTotalLength();
  return function(i) {
    return function(t) {
      // Put in try/catch because sometimes floating point is stupid..
      try {
        var p = path.getPointAtLength(t * l);
        return "translate(" + p.x + "," + p.y + ")";
      }
      catch(err) {
        console.log("Caught exception.");
        return "ERROR";
      }
    }
  }
}

function handleTraffic(msg) {
  var serviceRGB = msg.servicergb;
  var from = lookupTeam(msg.from)

  // Always send from the center of the box, but hit the target at a random point within a boundary of 10
  var fromMidX, fromMidY, toRandomX, toRandomY, bend;
  fromMidX = 98;
  fromMidY = 74;
  toMidX = Math.floor(Math.random() * (120 - 10 + 1)) + 10;
  toMidY = Math.floor(Math.random() * (120 - 10 + 1)) + 10;
  bend = true;

  console.log(from)
  console.log(from.x)
  var to = lookupTeam(msg.to)
  console.log(to)
  console.log(to.x)

  var lineData = [{"x":from.x+fromMidX, "y":from.y+fromMidY},
          calcMidpoint(from.x+fromMidX, from.y+fromMidY, to.x+toMidX, to.y+toMidY, bend),
          {"x":to.x+toMidX,"y":to.y+toMidY}];

  var lineFunction = d3.svg.line()
      .interpolate("basis")
      .x(function(d) { return d.x; })
      .y(function(d) { return d.y; });

  var lineGraph = svg.append("path")
      .attr("d", lineFunction(lineData))
      .attr("opacity",0.8)
      .attr("stroke", serviceRGB)
      .attr("stroke-width", 2)
      .attr("fill", "none");

  if (translateAlong(lineGraph.node()) === "ERROR") {
    return;
  }

  var circleRadius = msg.size;

  // Circle follows the line
  var dot = svg.append("circle")
          .attr("r", circleRadius)
          .attr("fill",serviceRGB)
          .transition()
            .duration(3000)
            .ease("ease-in")
            .attrTween("transform", translateAlong(lineGraph.node()))
            .each("end", function() {
              d3.select(this)
                          .transition().duration(500).attr("r", circleRadius * 2.5)
              .style("opacity",0).remove(); } );


  var length = lineGraph.node().getTotalLength();
  lineGraph.attr("stroke-dasharray", length + " " + length)
      .attr("stroke-dashoffset", length)
      .transition()
          .duration(3000)
          .ease("ease-in")
          .attr("stroke-dashoffset",0)
          .each("end", function() {
            d3.select(this).
            transition().duration(100).style("opacity",0).remove();
          });
}

/**
 * Translates a relative location to an x coordinate.
 */
function getTeamX(loc) {
  var windowWidth = document.body.clientWidth;
  switch(loc) {
    case "top-left":
    case "left":
    case "bottom-left":
      return BORDER_WIDTH;
    case "top":
    case "middle":
    case "bottom":
      return (windowWidth / 2) - (TEAM_WIDTH / 2);
    case "top-right":
    case "right":
    case "bottom-right":
      return windowWidth - TEAM_WIDTH - BORDER_WIDTH;
  }
  return null;
}

/**
 * Translates a relative location to a y coordinate.
 */
function getTeamY(loc) {
  var windowHeight = document.body.clientHeight;
  var teamAreaHeight = windowHeight - LEGEND_HEIGHT - BORDER_WIDTH;
  switch(loc) {
    case "top-left":
    case "top":
    case "top-right":
      return BORDER_WIDTH;
      break;
    case "left":
    case "middle":
    case "right":
      return (teamAreaHeight / 2) - (TEAM_HEIGHT / 2);
    case "bottom-left":
    case "bottom":
    case "bottom-right":
      return teamAreaHeight - TEAM_HEIGHT - BORDER_WIDTH;
  }
  return null;
}

/**
 * Handles resize events. Redraw all svg elements.
 */
function redraw()
{
  var windowWidth = document.body.clientWidth;
  var windowHeight = document.body.clientHeight;

  // resize the svg
  svg.attr("width", windowWidth)
     .attr("height", windowHeight);

  // resize the legend
  svg.selectAll(".legend")
     .attr("y", windowHeight - LEGEND_HEIGHT - BORDER_WIDTH)
     .attr("width", document.body.clientWidth - BORDER_WIDTH * 2);

  // move teams appropriately
  svg.selectAll(".team").data(g_teams)
     .attr("x", function(d) { return getTeamX(d.location); })
     .attr("y", function(d) { return getTeamY(d.location); });
}

/**
 * Creates boxes for individual teams in response to a websocket message.
 *
 * This message should only be received once during websocket initialization.
 * Team locations are specified as relative locations, and are translated to
 * x/y coordinates in javascript.
 */
function handleTeams(msg) {
  g_teams = msg.teams;

  var team = svg.selectAll(".team").data(g_teams).enter().append("svg")
                .attr("x", function(d) { return getTeamX(d.location); })
                .attr("y", function(d) { return getTeamY(d.location); })
                .classed("team", true);

  team.append("rect")
      .attr("x", 0)
      .attr("y", 0)
      .attr("width", TEAM_WIDTH)
      .attr("height", TEAM_HEIGHT)
      .attr("class", "blueTeam");

  team.append("foreignObject")
      .attr("x", 1)
      .attr("y", 1)
      .attr("z", 100)
      .attr("height", TEAM_HEIGHT - 2)
      .attr("width", TEAM_WIDTH - 2)
      .append("xhtml:span")
        .html(function(d) { return d.name; });
}

/**
 * Creates the legend in response to a websocket message.
 *
 * This message should only be received once during websocket initialization.
 */
function handleLegend(msg) {
  var services = msg.services;

  var legendHtml = "";
  for (var i = 0; i < services.length; i++) {
    legendHtml += "<font color=\"" + services[i].color + "\">";
    legendHtml += "[" + services[i].name.toUpperCase() + "] ";
    legendHtml += "</font>";
  }

  var legendWidth = document.body.clientWidth - BORDER_WIDTH * 2;
  var windowHeight = document.body.clientHeight;

  var g = svg.append("svg")
             .attr("x", BORDER_WIDTH)
             .attr("y", windowHeight - LEGEND_HEIGHT - BORDER_WIDTH)
             .attr("width", legendWidth)
             .attr("height", LEGEND_HEIGHT)
             .classed("legend", true);


  g.append("rect")
   .attr("x", 0)
   .attr("y", 0)
   .attr("width", "100%")
   .attr("height", "100%");

  g.append("foreignObject")
   .attr("x", "1%")
   .attr("y", "1%")
   .attr("width", "99%")
   .attr("height", "99%")
   .append("xhtml:span")
     .attr("style", "font-size: 1.9em")
     .html(legendHtml);
}


/**
 * Dispatch messages from the websocket.
 */
webSocket.onmessage = function (e) {
  // Put everything in an try/catch so we don't crash. Rather ignore a packet than crash the
  // display during the competition.

  //try {
    var msg = JSON.parse(e.data);
    console.log(msg);
    switch(msg.type) {
      case "legend":
        handleLegend(msg);
        break;
      case "teams":
        handleTeams(msg);
        break;
      case "traffic":
        handleTraffic(msg);
        break;
    }
  //}
  //catch(err) {
  //  console.log("Recovered from error.")
  //}
};

// handle resize events from the browser
window.addEventListener("resize", redraw);
</script>
</body>
</html>
