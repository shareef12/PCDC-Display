<html>
<head>

<script src="/static/d3.min.js"></script>
<link href='/static/index.css' rel='stylesheet'>

</head>

<body>

<script>
var proto = (window.location.protocol === "https") ? "wss:" : "ws:";
var webSocket = new WebSocket(proto + "//" + location.host + "/websocket");

var WIDTH = 1024;
var HEIGHT = 768;
var BORDER_WIDTH = 10;

var g_teams = [];
var g_legend = null;

var svg = d3.select("body").append("svg")
                           .attr("width", WIDTH)
                           .attr("height", HEIGHT)
                           .attr("class", "pcdccontainer");


function lookupTeam(teamname) {
  return d3.selectAll("rect")
    .filter(function(d) {
      return d.name === teamname;
    })
    .data()[0];
}

function calcMidpoint(x1, y1, x2, y2, bend) {
  if (y2 < y1 && x2 < x1) {
    var tmpy = y2;
    var tmpx = x2;
    x2 = x1;
    y2 = y1;
    x1 = tmpx;
    y1 = tmpy;
  }
  else if (y2 < y1) {
    y1 = y2 + (y2=y1, 0);
  }
  else if (x2 < x1) {
    x1 = x2 + (x2=x1, 0);
  }

  var radian = Math.atan(-((y2 - y1) / (x2 - x1)));
  var r = Math.sqrt(x2 - x1) + Math.sqrt(y2 - y1);
  var m1 = (x1 + x2) / 2;
  var m2 = (y1 + y2) / 2;

  var min = 2.5, max = 7.5;
  //var min = 1, max = 7;
  var arcIntensity = parseFloat((Math.random() * (max - min) + min).toFixed(2));

  if (bend === true) {
    var a = Math.floor(m1 - r * arcIntensity * Math.sin(radian));
    var b = Math.floor(m2 - r * arcIntensity * Math.cos(radian));
  }
  else {
    var a = Math.floor(m1 + r * arcIntensity * Math.sin(radian));
    var b = Math.floor(m2 + r * arcIntensity * Math.cos(radian));
  }

  return {"x": a, "y": b};
}

function translateAlong(path) {
  var l = path.getTotalLength();
  return function(i) {
    return function(t) {
      // Put in try/catch because sometimes floating point is stupid..
      try {
        var p = path.getPointAtLength(t * l);
        return "translate(" + p.x + "," + p.y + ")";
      }
      catch(err) {
        console.log("Caught exception.");
        return "ERROR";
      }
    }
  }
}

function handleTraffic(msg) {
  var serviceRGB = msg.servicergb;
  var from = lookupTeam(msg.from)

  // Always send from the center of the box, but hit the target at a random point within a boundary of 10
  var fromMidX, fromMidY, toRandomX, toRandomY, bend;
  fromMidX = 98;
  fromMidY = 74;
  toMidX = Math.floor(Math.random() * (120 - 10 + 1)) + 10;
  toMidY = Math.floor(Math.random() * (120 - 10 + 1)) + 10;
  bend = true;

  console.log(from)
  console.log(from.x)
  var to = lookupTeam(msg.to)
  console.log(to)
  console.log(to.x)

  var lineData = [{"x":from.x+fromMidX, "y":from.y+fromMidY},
          calcMidpoint(from.x+fromMidX, from.y+fromMidY, to.x+toMidX, to.y+toMidY, bend),
          {"x":to.x+toMidX,"y":to.y+toMidY}];

  var lineFunction = d3.svg.line()
      .interpolate("basis")
      .x(function(d) { return d.x; })
      .y(function(d) { return d.y; });

  var lineGraph = svg.append("path")
      .attr("d", lineFunction(lineData))
      .attr("opacity",0.8)
      .attr("stroke", serviceRGB)
      .attr("stroke-width", 2)
      .attr("fill", "none");

  if (translateAlong(lineGraph.node()) === "ERROR") {
    return;
  }

  var circleRadius = msg.size;

  // Circle follows the line
  var dot = svg.append("circle")
          .attr("r", circleRadius)
          .attr("fill",serviceRGB)
          .transition()
            .duration(3000)
            .ease("ease-in")
            .attrTween("transform", translateAlong(lineGraph.node()))
            .each("end", function() {
              d3.select(this)
                          .transition().duration(500).attr("r", circleRadius * 2.5)
              .style("opacity",0).remove(); } );


  var length = lineGraph.node().getTotalLength();
  lineGraph.attr("stroke-dasharray", length + " " + length)
      .attr("stroke-dashoffset", length)
      .transition()
          .duration(3000)
          .ease("ease-in")
          .attr("stroke-dashoffset",0)
          .each("end", function() {
            d3.select(this).
            transition().duration(100).style("opacity",0).remove();
          });
}

function getTeamX(loc) {
  var teamWidth = 200;
  switch(loc) {
    case "top-left":
    case "left":
    case "bottom-left":
      return BORDER_WIDTH;
    case "top":
    case "middle":
    case "bottom":
      return (WIDTH / 2) - (teamWidth / 2);
    case "top-right":
    case "right":
    case "bottom-right":
      return WIDTH - teamWidth - BORDER_WIDTH;
  }
  return null;
}

function getTeamY(loc) {
  var teamHeight = 150;
  switch(loc) {
    case "top-left":
    case "top":
    case "top-right":
      return BORDER_WIDTH;
      break;
    case "left":
    case "middle":
    case "right":
      return ((HEIGHT - 82) / 2) - (teamHeight / 2);
    case "bottom-left":
    case "bottom":
    case "bottom-right":
      return (HEIGHT - 82) - teamHeight - BORDER_WIDTH;
  }
  return null;
}

function redrawTeams()
{
  var g = svg.append("g");
}

function handleTeams(msg) {
  // TODO: Calculate these based on a percentage of screen size
  g_teams = msg.teams;
  var teamWidth = 200;
  var teamHeight = 150;

  for (var i = 0; i < g_teams.length; i++) {
    // Set team x and y location
    var x = getTeamX(g_teams[i].location);
    var y = getTeamY(g_teams[i].location);

    // TODO: Set color and size based on msg
    // TODO: Ensure we set the name attribute correctly for generating traffic
    var g = svg.append("svg")
               .attr("x", x)
               .attr("y", y);

    g.append("rect")
     .attr("x", 0)
     .attr("y", 0)
     .attr("width", teamWidth)
     .attr("height", teamHeight)
     .attr("class", "blueTeam");

    g.append("foreignObject")
     .attr("x", 1)
     .attr("y", 1)
     .attr("z", 100)
     .attr("height", teamHeight - 2)
     .attr("width", teamWidth - 2)
     .append("xhtml:span")
     .html(g_teams[i].name);
  }
}

function handleLegend(msg) {
  var services = msg.services;

  var legendHtml = "";
  for (var i = 0; i < services.length; i++) {
    legendHtml += "<font color=\"" + services[i].color + "\">";
    legendHtml += "[" + services[i].name.toUpperCase() + "] ";
    legendHtml += "</font>";
  }

  // TODO: Dynamically set legend_width
  var legend_height = 82;
  var legend_width = 1014;
  var g = svg.append("g");
  g.append("rect")
   .attr("x", 10)
   .attr("y", 768 - legend_height)
   .attr("height", legend_height)
   .attr("width", legend_width)
   .attr("class", "legend");

  g.append("foreignObject")
   .attr("x", 11)
   .attr("y", 768 - legend_height + 1)
   .attr("height", legend_height - 2)
   .attr("width", legend_width - 2)
   .append("xhtml:span")
   .attr("width", legend_width)
   .attr("style", "font-size: 1.9em")
   .html(legendHtml);
}

webSocket.onmessage = function (e) {
  // Put everything in an try/catch so we don't crash. Rather ignore a packet than crash the
  // display during the competition.

  //try {
    var msg = JSON.parse(e.data);
    console.log(msg);
    switch(msg.type) {
      case "legend":
        handleLegend(msg);
        break;
      case "teams":
        handleTeams(msg);
        break;
      case "traffic":
        handleTraffic(msg);
        break;
    }
  //}
  //catch(err) {
  //  console.log("Recovered from error.")
  //}
};
</script>
</body>
</html>
